import { Component, Prop, h, Host, Event, State, Listen, } from '@stencil/core';
export class TableHeaderCell {
  constructor() {
    this.sortable = false;
    this.sortingDirection = '';
    this.sortedByMyKey = false;
    this.disableSortingBtn = false;
    this.sortButtonClick = (key) => {
      // Toggling direction of sorting as we only use one button for sorting
      if (this.sortingDirection !== 'asc') {
        this.sortingDirection = 'asc';
      }
      else {
        this.sortingDirection = 'desc';
      }
      // Setting to true we can set enable CSS class for "active" state of column
      this.sortedByMyKey = true;
      // Use array to send both key and sorting direction
      this.sortColumnData.emit([key, this.sortingDirection]);
    };
    this.onHeadCellHover = (key) => {
      this.headKey.emit(key);
    };
    this.headerCellContent = () => {
      if (this.sortable && !this.disableSortingBtn) {
        return (h("button", { class: "sdds-table__header-button", onClick: () => this.sortButtonClick(this.columnKey) },
          h("span", { class: "sdds-table__header-button-text", style: { textAlign: this.textAlignState } }, this.columnTitle),
          this.sortingDirection === '' && (h("svg", { class: "sdds-table__header-button-icon", fill: "none", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 12 15" },
            h("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M8.45 13.67V4.62a.5.5 0 0 1 1 0v9.05h-1Z", fill: "currentColor" }),
            h("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M6.07 10.28a.5.5 0 0 1 .7.08l2.1 2.66a.1.1 0 0 0 .15 0l2.09-2.66a.5.5 0 1 1 .78.62l-2.08 2.66a1.1 1.1 0 0 1-1.73 0l-2.1-2.66a.5.5 0 0 1 .1-.7ZM3.55.4v9.04a.5.5 0 1 1-1 0V.39h1Z", fill: "currentColor" }),
            h("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M5.93 3.78a.5.5 0 0 1-.7-.08l-2.1-2.66a.1.1 0 0 0-.15 0L.89 3.7a.5.5 0 0 1-.78-.62L2.19.42a1.1 1.1 0 0 1 1.73 0l2.1 2.66a.5.5 0 0 1-.1.7Z", fill: "currentColor" }))),
          this.sortingDirection !== '' && (h("svg", { class: `sdds-table__header-button-icon ${this.sortingDirection === 'desc'
              ? 'sdds-table__header-button-icon--rotate'
              : ''}`, fill: "none", xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 32 32" },
            h("path", { "fill-rule": "evenodd", "clip-rule": "evenodd", d: "M17 2.974a1 1 0 0 0-2 0v24.3l-9.312-9.312a1 1 0 0 0-1.414 1.414l9.887 9.888a2.6 2.6 0 0 0 3.677 0l9.888-9.888a1 1 0 0 0-1.414-1.414L17 27.274v-24.3Z", fill: "currentColor" })))));
      }
      return (h("p", { class: "sdds-table__header-text", style: { textAlign: this.textAlignState } }, this.columnTitle));
    };
  }
  componentWillLoad() {
    // enable only right or left text align
    if (this.textAlign === 'right' || this.textAlign === 'end') {
      this.textAlignState = 'right';
    }
    else {
      this.textAlignState = 'left';
    }
    // To enable body cells text align per rules set in head cell
    this.bodyCellData.emit([this.columnKey, this.textAlignState]);
  }
  // target is set to body so other instances of same component "listen" and react to the change
  updateOptionsContent(event) {
    // grab only value at position 0 as it is the "key"
    const keyValue = event.detail[0];
    if (keyValue !== this.columnKey) {
      this.sortedByMyKey = false;
      // To sync with CSS transition timing
      setTimeout(() => {
        this.sortingDirection = '';
      }, 200);
    }
  }
  // Listen to parent table if sorting is allowed
  updateSortingStatus(event) {
    this.disableSortingBtn = event.detail;
  }
  render() {
    return (h(Host, { class: {
        'sdds-table__header-cell': true,
        'sdds-table__header-cell--sortable': this.sortable,
        'sdds-table__header-cell--is-sorted': this.sortedByMyKey,
        'sdds-table__header-cell--custom-width': this.customWidth !== '',
        'sdds-table__header-cell--right-align': this.textAlignState === 'right',
      }, style: { width: this.customWidth }, 
      // Calling actions from here to enable hover functionality for both sortable and un-sortable tables
      onMouseOver: () => this.onHeadCellHover(this.columnKey), onMouseLeave: () => this.onHeadCellHover('') }, this.headerCellContent()));
  }
  static get is() { return "sdds-header-cell"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["table.scss"]
  }; }
  static get styleUrls() { return {
    "$": ["table.css"]
  }; }
  static get properties() { return {
    "columnKey": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "column-key",
      "reflect": true
    },
    "columnTitle": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "column-title",
      "reflect": true
    },
    "customWidth": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "custom-width",
      "reflect": true
    },
    "textAlign": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "text-align",
      "reflect": true
    },
    "sortable": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": ""
      },
      "attribute": "sortable",
      "reflect": false,
      "defaultValue": "false"
    }
  }; }
  static get states() { return {
    "textAlignState": {},
    "sortingDirection": {},
    "sortedByMyKey": {},
    "disableSortingBtn": {}
  }; }
  static get events() { return [{
      "method": "sortColumnData",
      "name": "sortColumnData",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": ""
      },
      "complexType": {
        "original": "any",
        "resolved": "any",
        "references": {}
      }
    }, {
      "method": "bodyCellData",
      "name": "bodyCellData",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": ""
      },
      "complexType": {
        "original": "any",
        "resolved": "any",
        "references": {}
      }
    }, {
      "method": "headKey",
      "name": "headKey",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": ""
      },
      "complexType": {
        "original": "any",
        "resolved": "any",
        "references": {}
      }
    }]; }
  static get listeners() { return [{
      "name": "sortColumnData",
      "method": "updateOptionsContent",
      "target": "body",
      "capture": false,
      "passive": false
    }, {
      "name": "sortingEnabler",
      "method": "updateSortingStatus",
      "target": "body",
      "capture": false,
      "passive": false
    }]; }
}
